// main.go
// Generated by ChatGPT on 2024-06-16
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os/exec"
	"sync"
)

type Stream struct {
	Key   string `json:"key"`
	Image string `json:"image"`
}

var streams = make(map[string]*exec.Cmd)
var streamsMutex = &sync.Mutex{}

func main() {
	http.HandleFunc("/api/v1/ping", pingHandler)
	http.HandleFunc("/api/v1/start_stream", startStreamHandler)
	http.HandleFunc("/api/v1/stop_stream", stopStreamHandler)
	http.HandleFunc("/api/v1/streams", listStreamsHandler)

	log.Println("Server started at :8080")
	log.Fatal(http.ListenAndServe(":8080", nil))
}

func pingHandler(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("pong"))
}

func startStreamHandler(w http.ResponseWriter, r *http.Request) {
	var stream Stream
	err := json.NewDecoder(r.Body).Decode(&stream)
	if err != nil || stream.Key == "" {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	imagePath := "imgs/default.png"
	if stream.Image != "" {
		imagePath = stream.Image
	}

	streamsMutex.Lock()
	if _, exists := streams[stream.Key]; exists {
		streamsMutex.Unlock()
		http.Error(w, "Stream already exists", http.StatusConflict)
		return
	}

	cmd := exec.Command("ffmpeg", "-re", "-loop", "1", "-f", "image2", "-i", imagePath, "-f", "lavfi", "-i", "anullsrc", "-c:v", "libx264", "-preset", "ultrafast", "-tune", "stillimage", "-pix_fmt", "yuv420p", "-b:v", "200k", "-maxrate", "200k", "-bufsize", "400k", "-c:a", "aac", "-ar", "44100", "-b:a", "64k", "-f", "flv", fmt.Sprintf("rtmp://a.rtmp.youtube.com/live2/%s", stream.Key))
	err = cmd.Start()
	if err != nil {
		streamsMutex.Unlock()
		http.Error(w, "Failed to start stream", http.StatusInternalServerError)
		return
	}

	streams[stream.Key] = cmd
	streamsMutex.Unlock()

	go func() {
		err := cmd.Wait()
		if err != nil {
			log.Printf("Stream %s stopped with error: %v", stream.Key, err)
		}
	}()

	log.Printf("Stream %s started", stream.Key)
	w.WriteHeader(http.StatusOK)
}

func stopStreamHandler(w http.ResponseWriter, r *http.Request) {
	var stream Stream
	err := json.NewDecoder(r.Body).Decode(&stream)
	if err != nil || stream.Key == "" {
		http.Error(w, "Invalid request", http.StatusBadRequest)
		return
	}

	streamsMutex.Lock()
	cmd, exists := streams[stream.Key]
	if !exists {
		streamsMutex.Unlock()
		http.Error(w, "Stream not found", http.StatusNotFound)
		return
	}

	err = cmd.Process.Kill()
	if err != nil {
		streamsMutex.Unlock()
		http.Error(w, "Failed to stop stream", http.StatusInternalServerError)
		return
	}

	delete(streams, stream.Key)
	streamsMutex.Unlock()

	log.Printf("Stream %s stopped", stream.Key)
	w.WriteHeader(http.StatusOK)
}

func listStreamsHandler(w http.ResponseWriter, r *http.Request) {
	streamsMutex.Lock()
	defer streamsMutex.Unlock()

	var activeStreams []string
	for key := range streams {
		activeStreams = append(activeStreams, key)
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(activeStreams)
}
